A generator will output a sequence of parameters. These parameters can be used to drive a realtime system or render a file for later driving a realtime system (e.g. live midi vs a midi file)

A single parameter value
60
-60.5
'arbitrary text'


Special syntax for a single parameter value
pitch:    c#4 
velocity: mf
duration: q


A single parameter list (e.g. a chord)
[60 63 67]


A sequence of parameter values
(60 62 64)   - parentheses optional
or mixing single values and lists
(60 62 [64 47] 62 60)


A multi parameter event (a 'chain')
60:127
C4:mp
C#4:mf:q

Repetition
60*2
c4:mf*4
(60 62)*3
60*0 (doesn't play at all)

Stay **
50**
(1 2)**
Repeats infinitely until forced to advance.


Advance (other part of chain)
(1** 2):(1 1 1 > 2)
'>' will advance the first part of the chain
(1** 2):(mp mf** fff):(1 1 > > 1 2 -> 3)
-> indicates second chain (--> would be third, etc)


(*3=> 1 2 3)
MAYBE: apply operator to all elements of subsequence?
or:
(1 2 3)@*3


Choice of single value
(c4 | e4 | g4)

Choice of subsequence
(c4 e4 | e4 g4 | g4 b4)

Picks two (simultneous playback)
(c4 e4 g4 || e4 g4 c5 || g4 c5 e5)

plays back all three 
(c4 e4 g4 ||| e4 g4 c5 ||| g4 c5 e5)

Parallel Playback
c4 e4 g4 || e4 g4 c5
might want to use newlines:
c4 e4 g4
||
e4 g4 c5

Since the number of bars indicates how many choices we select, there is a shorthand for
choose all which is '/':
c4 e4 g4 / e4 g4 c5
might want to use newlines:
c4 e4 g4
/
e4 g4 c5

Nested Parallel Playback
a4 b4 (c4 e4 g4 || e4 g4 c5 || g4 c5 e5)



Sequence Output Limit (sort of like repetition but indicates the maximum number of values that will be output):
(60 62 64)&4
will output 60 62 64 60
Nesting:
(1 (2 3)&3 4)&7
1 2 3 2 4 1 2


Ruby Expression
{600/10}
('how' 'many' 'repetitions?')*{rand 10}
The ruby expression will be deferred until the generator needs to value
NOTE: for repetitions we can indicate whether a re-evaluation will occur via use of the ! operator:
( {'reeval each repeat'} {'eval when this sequence starts'}! )*2
'!' is like "do this right away, and I mean I want this value"
TODO: need ability to evaluate as a single value or as a sequence


Multi-generator:
(60 62 64):(p mp mf)
equivalent to: 60:p 62:mp 64:mf

now it gets complicated!
(60 62):(p mp f)
this could output 
[1] 60:p 62:mp
or
[2] 60:p 62:mp 60:f
or
[3] 60:p 62:mp 60:f 62:p 60:mp 62:f

it depends on the rule for the multigenerator
default is [2], go until longest subseqs run out
(60 62)!:(p mp f) would do [1], loop other sequences until the important! seq runs out
(60 62):(p mp f)!&4 would loop until four events are output
(60 62)!:(p mp f)! will loop until all parameters line up on the last value together (all important seq must run out at same time) [3]

how about this idea, a "line":
(c4 d4 e4 f4 g4)=(p f)
this will do an (interpolated) crescendo from c4 to g4 over the length of the other sequence
but hmm, what about:
(c4 d4 e4 f4 g4)=(p f)=(q w)
I guess its like a chain but interpolates the shorter sequences over the longer one
if we want to "reverse interpolate" a longer sequence over a shorter one, maybe something like this:
(c4 d4 e4 f4 g4)=(p f)!=(q w)
now (p f) is the master subseq


variable assignments
$x = '1 2 3';

transformations:
$x.transpose12
$x.T12
should I also support:
(1 2 3).T12

destructive method call:
(1 2 3).T!12
every time this node is evaluated it will go up another octave!

'10:$x 15:$x'
== 10:(1 2 3) 15:(1 2 3)


foreach
'(1 2 3)@(10:$ 15:$)'  or $x@(10:$ 15:$)
== (10:1 15:1) (10:2 15:2) (10:3 15:3)


operators to affect sequence output
(1 2 3) --> 1 2 3
(1 2 3)*3 --> 1 2 3 1 2 3 1 2 3
(1 2 3)&5 --> 1 2 3 1 2
NOT NOW (1 2 3)~2 --> 1 2 3 2 1
NOT NOW (1 2 3)~&6 --> 1 2 3 2 1 2
NOT NOW (1 2 3)~3 --> 1 2 3 2 1 2 3
NOT NOW (1 2 3)~~3 --> 1 2 3  3 2 1  1 2 3  (endpoint repetition)
NOT NOW (1 2 3) <what operator?> 3 --> 1 2 3  2 3 1  3 1 2  (rotational)
how about .R for rotate with a destrutive version so I could do:
((3 1 2).R!1)*3  but since the first time we evaluate this it will rotate,
it is a little unnatural... hmmm...

SYNTAX (these are like choices, do we want)
(1 2 3)&1? --> randomly select a single value in the sequence
NO, already have: (1 | 2 | 3)
(1 2 3)&2? --> randomly select two values in the sequence
NO: (1|2|3)&2
(1 2 3)*1? --> random permutation of all values in sequence (default, option '*1')
NO:(1 2 3).permute or (1 2 3).P
(1 2 3)*2? --> 2 random permutations of all values in sequence
(1 2 3).P*2 (it will reevaluate)
Hmmm... need to distinguish between sample with replacement and without replacement (can duplicates occur during a repeated sampling)
(1 2 3).PR (permutation with replacement)


(4 (1|2|3)^ 5)*2 --> choose a value and remember it? '^' moves evaluation up to higher scope


(1->2->3) --> (syntax?) each time through the sequence, choose one value deterministically. first time we choose, take the first value, second time, take the second, etc
NO? this is handled by foreach

probability
1%50 output 1 50% of the time, otherwise skip the value (or rest/nil? how do we configure that? maybe use '?'
(1 2 3)%33 or (1 2 3)%%0.33333  or (1 2 3)%%{1/3.0}  output the sequence 33 percent of the time, %% means it is a percentage/100

NOT NOW? apply to all values in the sequence:
(*3=> 1 2 3)  --> 1 1 1 2 2 2 3 3 3
or (1 2 3)@*3
((*3=> 1 2 3))*3  --> 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 
(%50=> 1 2 3)
or (1 2 3)@%50

({this.probability = 0.5}=> 1 2 3)<- [TODO: need to think about how current value/sequence can be exposed to scripting]


advanced constructs
(1 2 3)~:('a' 'b' 'c' 'd' 'e' 'f'):('.' '\'')  --> 1:a:. 2:b:' 3:c:. 2:d:' 1:e:. 2:f:'


precedence rules:
: has highest precedence
' ' (whitespace separated sequence list)
| 


custom types:
#env:[]