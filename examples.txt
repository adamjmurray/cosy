A generator will output a sequence of parameters. These parameters can be used to drive a realtime system or render a file for later driving a realtime system (e.g. live midi vs a midi file)

A single parameter value
60
-60.5
'arbitrary text'


Special syntax for a single parameter value
<pitch> c#4 
<velocity> mf
<duration> q
angle brackets specify a parsing mode/command


A single parameter list (e.g. a chord)
[60 63 67]


A sequence of parameter values
(60 62 64)
or mixing single values and lists
(60 62 [64 47] 62 60)


A multi parameter event
60:127
C4:mp
C#4:mf:q
These would be configurable via parsing mode/commands, like
<pitch:velocity>
<pitch:velocity:duration>
<duration:pitch> w:c4 h:d4
<pitch:?> c4:'arbitrary text'


Repetition
60*2
c4:mf*4
(60 62)*3
60*0
prev one doesn't play at all
50*@
prev repeats infinitely. it's like "stay at" this sequence, and it kind of looks like a loop. requires some external input to stop/advance, only works for realtime stuff. TODO: figure out input interface


Sequence Output Limit (sort of like repetition but indicates the maximum number of values that will be output):
(60 62 64)&4
will output 60 62 64 60


Ruby Expression
{600/10}
('how' 'many' 'repetitions?')*{rand 10}
The ruby expression will be deferred until the generator needs to value
NOTE: for repetitions we can indicate whether a re-evaluation will occur via use of the ! operator:
( {'reeval each repeat'} {'eval when this sequence starts'}! )*2
'!' is like "do this right away, and I mean I want this value"
TODO: need ability to evaluate as a single value or as a sequence


Multi-generator:
(60 62 64):(p mp mf)
equivalent to: 60:p 62:mp 64:mf

now it gets complicated!
(60 62):(p mp f)
this could output 
[1] 60:p 62:mp
or
[2] 60:p 62:mp 60:f
or
[3] 60:p 62:mp 60:f 62:p 60:mp 62:f

it depends on the rule for the multigenerator
default is [2], go until all subseqs run out
(60 62)!:(p mp f) would do [1], loop other sequences until the important! seq runs out
((60 62):(p mp f))&4 would loop until four events are output
((60 62):(p mp f))&? will loop until all parameters line up on the last value together [3]



operators to affect sequence output
(1 2 3) --> 1 2 3
(1 2 3)*3 --> 1 2 3 1 2 3 1 2 3
(1 2 3)&5 --> 1 2 3 1 2
NOT NOW (1 2 3)^2 --> 1 2 3 2 1
NOT NOW (1 2 3)^3 --> 1 2 3 2 1 2 3
NOT NOW TODO --> 1 2 3  3 2 1  1 2 3  (bi-directional with endpoint repetition)
NOT NOW TODO --> 1 2 3  2 3 1  3 1 2  (rotational)
(1 2 3)?1 --> randomly select a single value in the sequence (loopable of course!)
(1 2 3)?2 --> randomly select two values in the sequence (loopable of course!)
(1 2 3)?? --> random permutation of all values in sequence
(4 (1 2 3)?! 5)*2 --> choose a value and remember it? what is the scope on '!'
(1|2|3) --> each time through the sequence, choose one value deterministically. first time we choose, take the first value, second time, take the second, etc

probability
1%50 output 1 50% of the time, otherwise skip the value (or rest/nil? how do we configure that?)
(1 2 3)%33 or (1 2 3)%0.33333  or (1 2 3)%{1/3.0}  output the sequence 33 percent of the time

NOT NOW? apply to all values in the sequence:
(1 2 3)<-*3  --> 1 1 1 2 2 2 3 3 3
((1 2 3)<-*3)*3  --> 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 
(1 2 3)<-%50
(1 2 3)
(1 2 3)<-{this.probability = 0.5} [TODO: need to think about how current value/sequence can be exposed to scripting]


advanced constructs
(1 2 3)^:('a' 'b' 'c' 'd' 'e' 'f'):('.' '\'')  --> 1:a:. 2:b:' 3:c:. 2:d:' 1:e:. 2:f:'
